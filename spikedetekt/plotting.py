'''
Various tools for plotting
'''

from pylab import *
import tables

class AttributeToItem(object):
    '''
    Convenience class so you can write obj.name instead of obj['name'],
    useful for row objects returned from PyTables
    '''
    def __init__(self, obj):
        self.obj = obj
    def __getitem__(self, name):
        return self.obj[name]
    def __getattr__(self, name):
        return self.obj[name]

class SpikeTable(object):
    '''
    Class for loading data from a .h5 file generated by SpikeDetekt
    
    Usage::
    
        st = SpikeTable(filename)
        ...
        st.close()
        
    Some properties include::
    
        st.numspikes
        st.numchannels
        st.features_per_channel
        st.numfeatures
        st.samples_per_spike
        
    You can access an individual spike like this::
    
        spike = st[0]
        
    or::
    
        for spike in st:
            ...
            
    For a spike object, or for the entire spike table, you can access the
    stored attributes like this::
    
        spike.wave
        st.fet
        
    These return arrays, so if spike.wave has shape
    (samples_per_spike, numchannels) then st.wave would have shape
    (numspikes, samples_per_spike, numchannels) and so forth.
    
    Available attributes and their shapes for a spike include:
    
        time            (1)
        wave            (samples_per_spike, numchannels)
        fet             (numchannels, features_per_channel)
        channel_mask    (numchannels)
        fet_mask        (numfeatures)
        
    These are defined in spike_dtype() in files.py
    '''
    def __init__(self, filename):
        self.filename = filename
        self.hdf5file = tables.openFile(filename)
        self.spiketable = self.hdf5file.root.SpikeTable_temp
        self.numspikes = len(self.spiketable)
        self.numchannels = self.spiketable[0]['wave'].shape[1]
        self.features_per_channel = self.spiketable[0]['fet'].shape[1]
        self.numfeatures = self.spiketable[0]['fet_mask'].shape[0]
        self.samples_per_spike = self.spiketable[0]['wave'].shape[0]
    def __getitem__(self, i):
        return AttributeToItem(self.spiketable[i])
    def close(self):
        self.hdf5file.close()
    def __getattr__(self, name):
        return getattr(self.spiketable.cols, name)[:]

if __name__=='__main__':
    from mpl_toolkits.mplot3d import Axes3D
    st = SpikeTable('../testdata/originalmed_buzsaki32/originalmed_buzsaki32.h5')
    print 'Filename:', st.filename
    print 'Num spikes:', st.numspikes
    print 'Num channels:', st.numchannels
    print 'Features per channel:', st.features_per_channel
    print 'Num features:', st.numfeatures
    print 'Samples per spike:', st.samples_per_spike
    
    show_demo = False
    show_sample_spikes = True
    
    if show_demo:
        figure()
        
        # plot a wave for a spike with 5 unmasked channels
        subplot(221)
        for spike in st:
            if sum(spike.channel_mask)==5:
                break
        plot(spike.wave, c=(0.8,)*3)
        plot(spike.wave[:, spike.channel_mask.nonzero()[0]])
        title("Wave with unmasked channels")
        
        # plot channel
        gcf().add_subplot(222, projection='3d')
        fet = st.fet[:1000, :, :]
        for i, c in enumerate(['red', 'green', 'blue']):
            gca().scatter(fet[:, i, 0], fet[:, i, 1], fet[:, i, 2],
                          s=10, marker='.', facecolor=c, edgecolor='none')
        title("Features (XYZ) channels (RGB)")
        
        # unfiltered
        subplot(223)
        plot(spike.unfiltered_wave, c=(0.8,)*3)
        plot(spike.unfiltered_wave[:, spike.channel_mask.nonzero()[0]])
        title("Unfiltered")
        
        # histogram of number of unmasked channels
        num_unmasked = [sum(spike.channel_mask) for spike in st]
        subplot(224)
        hist(num_unmasked, bins=arange(st.numchannels+1))
        title('Number of unmasked channels')

    if show_sample_spikes:
        figure()
        i = 1
        for spike in st:
            # Finds positive threshold spikes only
#            if -amin(spike.wave)>amax(spike.wave):
#                continue
            # Finds only spikes with 3 or more channels
            if sum(spike.channel_mask)<3:
                continue
            subplot(4, 4, i)
            plot(spike.wave, c=(0.8,)*3)
            plot(spike.wave[:, spike.channel_mask.nonzero()[0]])
            axvline(spike.wave.shape[0]/2, ls='--', c='k')
            axis('tight')
            xticks([])
            yticks([])
            i += 1
            if i>16:
                break
    
    st.close()
    show()
